{"version":3,"sources":["retry.js"],"names":["retry","params","options","backoff","delay","maxAttempts","strategyOptions","initialDelay","maxDelay","length","retryDecorator","target","prop","descriptor","value","retryExecutor","fn","args","emitter","EventEmitter","promise","resolve","reject","call","cb","innerPromise","on","emit","bind","then","res","catch","reason","Error","err","setStrategy","ExponentialStrategy","failAfter","start","key","callback","prototype"],"mappings":"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","file":"retry.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\nimport {defaults, isFunction, wrap} from 'lodash';\nimport backoff from 'backoff';\n\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function retry(...params) {\n  let options = params[0] || {};\n\n  options = Object.assign({}, options);\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return Reflect.apply(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = wrap(descriptor.value, function retryExecutor(fn, ...args) {\n      const emitter = new EventEmitter();\n      const promise = new Promise((resolve, reject) => {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n        /* eslint prefer-reflect: [0] */\n        const call = backoff.call(\n          (cb) => {\n            /* eslint no-invalid-this: [0] */\n            const innerPromise = Reflect.apply(fn, this, args);\n\n            if (isFunction(innerPromise.on)) {\n              innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n              innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n              innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n            }\n\n            return innerPromise\n              .then((res) => {\n                cb(null, res);\n              })\n              .catch((reason) => {\n                if (!reason) {\n                  reason = new Error('retryable method failed without providing an error object');\n                }\n                cb(reason);\n              });\n          },\n          (err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          }\n        );\n\n        call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n        return promise;\n      };\n\n      return promise;\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}\n"]}