{"version":3,"sources":["webrtc-helpers.js"],"names":["getMediaDirectionFromSDP","getMediaFromSDP","reverseMediaDirection","limitBandwith","kindToPropertyFragment","getMediaDirectionFromSDPForAnswer","boolToDirection","getMediaDirectionFromTracks","removeExtmap","kind","sdp","query","content","type","media","direction","mediaTypes","forEach","m","sendrecv","recvonly","sendonly","filter","Error","ensureH264","wantsVideo","offer","includes","test","audioBandwidthLimit","videoBandwidthLimit","split","reduce","lines","line","push","startsWith","join","offerSdp","send","recv","pc","signalingState","senders","getSenders","s","track","length","acc","enabled","receivers","getReceivers","r","replace"],"mappings":"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","file":"webrtc-helpers.js","sourcesContent":["// we need to import the webrtc adapter before anything else happens\n/* eslint-disable import/first */\n\nimport './webrtc-adapter-adapter';\n\nimport {curry, find, filter} from 'lodash';\nimport {parse} from 'sdp-transform';\n\n/**\n * Pulls the direction line for the specified media kind from an sdp\n * @param {string} kind\n * @param {string} sdp\n * @protected\n * @returns {string}\n */\nexport function getMediaDirectionFromSDP(kind, sdp) {\n  const query = kind === 'screen' ? {\n    content: 'slides',\n    type: 'video'\n  } : {\n    type: kind\n  };\n\n  const media = find(parse(sdp).media, query);\n  if (!media) {\n    return 'inactive';\n  }\n\n  return media.direction;\n}\n\n/**\n *\n * @param {string} kind\n * @param {string} sdp\n * @param {string} direction\n * @protected\n * @returns {object}\n */\nexport function getMediaFromSDP(kind, sdp, direction) {\n  const query = kind === 'screen' ? {\n    content: 'slides',\n    type: 'video'\n  } : {\n    type: kind\n  };\n\n  let media = filter(parse(sdp).media, query);\n\n  const mediaTypes = {};\n\n  if (direction) {\n    if (direction === 'sendrecv') {\n      media.forEach((m) => {\n        mediaTypes[m.direction] = m;\n      });\n      // This adds support for when Firefox splits a sendrecv media connection into\n      // separate sendonly and recvonly connections. This is ok as long as both\n      // connections exist and are in the correct direction. Possibly a FF bug that\n      // will be resolved in the future.\n      if (mediaTypes.sendrecv && !mediaTypes.recvonly && !mediaTypes.sendonly) {\n        media = mediaTypes.sendrecv;\n      }\n      else if (!mediaTypes.sendrecv && mediaTypes.recvonly && mediaTypes.sendonly) {\n        media = [mediaTypes.recvonly, mediaTypes.sendonly];\n      }\n    }\n    else {\n      media = media.filter((m) => m.direction === direction);\n    }\n  }\n\n  return media;\n}\n\n/**\n * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)\n * @param {string} direction\n * @protected\n * @returns {string}\n */\nexport function reverseMediaDirection(direction) {\n  switch (direction) {\n    case 'inactive':\n    case 'sendrecv':\n      return direction;\n    case 'sendonly':\n      return 'recvonly';\n    case 'recvonly':\n      return 'sendonly';\n    default:\n      throw new Error(`direction \"${direction}\" is not valid`);\n  }\n}\n\n/**\n * Checks a given sdp to ensure it contains an offer for the h264 codec\n * @param {boolean} wantsVideo\n * @param {string} offer\n * @protected\n * @returns {string} returns the offer to simplify use in promise chains\n */\nexport const ensureH264 = curry((wantsVideo, offer) => {\n  if (wantsVideo) {\n    if (!offer.includes('m=video')) {\n      throw new Error('No video section found in offer');\n    }\n    if (!/[hH]264/.test(offer)) {\n      throw new Error('Offer does not include h264 codec');\n    }\n  }\n  return offer;\n});\n\n/**\n * Adds a bandwith limit line to the sdp; without this line, calling fails\n * @param {Object} bandwidthLimit\n * @param {string} sdp SDP\n * @protected\n * @returns {string} The modified SDP\n */\nexport function limitBandwith({audioBandwidthLimit, videoBandwidthLimit}, sdp) {\n  return sdp.split('\\r\\n').reduce((lines, line) => {\n    lines.push(line);\n    if (line.startsWith('m=')) {\n      lines.push(`b=TIAS:${line.includes('audio') ? audioBandwidthLimit : videoBandwidthLimit}`);\n    }\n    return lines;\n  }, []).join('\\r\\n');\n}\n\n/**\n * Helper for dealing wait capitalization\n * @param {string} kind audio|video\n * @protected\n * @returns {string} Audio|Video\n */\nexport function kindToPropertyFragment(kind) {\n  return kind === 'audio' ? 'Audio' : 'Video';\n}\n\n/**\n * Like get getMediaDirectionFromSDP, but reverses the the result\n * @param {string} kind\n * @param {string} offerSdp\n * @protected\n * @returns {string}\n */\nexport function getMediaDirectionFromSDPForAnswer(kind, offerSdp) {\n  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));\n}\n\n\n/**\n * Converts a pair of booleans to a SDP direction string\n * @param {boolean} send\n * @param {boolean} recv\n * @protected\n * @returns {string}\n */\nexport function boolToDirection(send, recv) {\n  if (send && recv) {\n    return 'sendrecv';\n  }\n\n  if (send) {\n    return 'sendonly';\n  }\n\n  if (recv) {\n    return 'recvonly';\n  }\n\n  return 'inactive';\n}\n\n/**\n * Determines the flow of media for a given kind of media on a peer connection\n * @param {string} kind\n * @param {RTCPeerConnection} pc\n * @protected\n * @returns {string}\n */\nexport function getMediaDirectionFromTracks(kind, pc) {\n  if (pc.signalingState === 'closed') {\n    return 'inactive';\n  }\n\n  const senders = pc\n    .getSenders()\n    .filter((s) => s.track && s.track.kind === kind);\n\n  const send = senders.length > 0 && senders.reduce((acc, s) => acc || s.track.enabled, false);\n\n  const receivers = pc\n    .getReceivers()\n    .filter((r) => r.track && r.track.kind === kind);\n\n  const recv = receivers.length > 0 && receivers.reduce((acc, r) => acc || r.track.enabled, false);\n  return boolToDirection(send, recv);\n}\n\n/**\n * Our services don't support extmap lines in sdps, so we need to remove them\n * @param {string} sdp\n * @returns {string}\n */\nexport function removeExtmap(sdp) {\n  return sdp.replace(/a=extmap.*\\r\\n/g, '');\n}\n"]}