{"version":3,"sources":["stream.js"],"names":["emittersByPc","pcsByEmitter","emittersByStream","timersByEmitter","schedule","emitter","timer","pc","get","getStats","then","stats","emit","signalingState","connectionState","catch","err","set","StatsStream","objectMode","has","EventEmitter","once","data","isPaused","push","Readable"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AACA;;AAEA;;;;AAEA,IAAMA,eAAe,uBAArB,C,CAPA;;AAQA,IAAMC,eAAe,uBAArB;AACA,IAAMC,mBAAmB,uBAAzB;AACA,IAAMC,kBAAkB,uBAAxB;;AAEA;;;;;;;AAOA,SAASC,QAAT,CAAkBC,OAAlB,EAA2B;AACzB,MAAMC,QAAQ,kCAAe,YAAM;AACjC,QAAMC,KAAKN,aAAaO,GAAb,CAAiBH,OAAjB,CAAX;AACAE,OAAGE,QAAH,GACGC,IADH,CACQ,UAACC,KAAD,EAAW;AACfN,cAAQO,IAAR,CAAa,MAAb,EAAqBD,KAArB;AACA;AACA;AACA;AACA,UAAI,EAAEJ,GAAGM,cAAH,KAAsB,QAAtB,IAAkCN,GAAGO,eAAH,KAAuB,QAA3D,CAAJ,EAA0E;AACxEV,iBAASC,OAAT;AACD;AACF,KATH,EAUGU,KAVH,CAUS,UAACC,GAAD,EAAS;AACdX,cAAQO,IAAR,CAAa,OAAb,EAAsBI,GAAtB;AACD,KAZH;AAaD,GAfa,EAeX,IAfW,CAAd;;AAiBAb,kBAAgBc,GAAhB,CAAoBZ,OAApB,EAA6BC,KAA7B;AACD;;AAED;;;;;IAIqBY,W;;;AACnB;;;;AAIA,uBAAYX,EAAZ,EAAgB;AAAA;;AAAA,gJACR,EAACY,YAAY,IAAb,EADQ;;AAGd,QAAI,CAACnB,aAAaoB,GAAb,CAAiBb,EAAjB,CAAL,EAA2B;AACzBP,mBAAaiB,GAAb,CAAiBV,EAAjB,EAAqB,IAAIc,oBAAJ,EAArB;AACD;AACD,QAAMhB,UAAUL,aAAaQ,GAAb,CAAiBD,EAAjB,CAAhB;;AAEA,QAAI,CAACL,iBAAiBkB,GAAjB,OAAL,EAAiC;AAC/BlB,uBAAiBe,GAAjB,QAA2BZ,OAA3B;AACD;AACD,QAAI,CAACJ,aAAamB,GAAb,CAAiBf,OAAjB,CAAL,EAAgC;AAC9BJ,mBAAagB,GAAb,CAAiBZ,OAAjB,EAA0BE,EAA1B;AACD;;AAEDF,YAAQiB,IAAR,CAAa,OAAb,EAAsB,UAACN,GAAD,EAAS;AAC7B,YAAKJ,IAAL,CAAU,OAAV,EAAmBI,GAAnB;AACD,KAFD;AAfc;AAkBf;;AAED;;;;;;;;;4BAKQ;AAAA;;AACN,UAAMX,UAAUH,iBAAiBM,GAAjB,CAAqB,IAArB,CAAhB;;AAEAH,cAAQiB,IAAR,CAAa,MAAb,EAAqB,UAACC,IAAD,EAAU;AAC7B,YAAI,CAAC,OAAKC,QAAL,EAAL,EAAsB;AACpB,iBAAKC,IAAL,CAAUF,IAAV;AACD;AACF,OAJD;;AAMA,UAAI,CAACpB,gBAAgBiB,GAAhB,CAAoBf,OAApB,CAAL,EAAmC;AACjCD,iBAASC,OAAT;AACD;AACF;;;EA1CsCqB,gB;;kBAApBR,W","file":"stream.js","sourcesContent":["/* eslint-disable require-jsdoc */\n\nimport {Readable} from 'stream';\nimport {EventEmitter} from 'events';\n\nimport {safeSetTimeout} from '@ciscospark/common-timers';\n\nconst emittersByPc = new WeakMap();\nconst pcsByEmitter = new WeakMap();\nconst emittersByStream = new WeakMap();\nconst timersByEmitter = new WeakMap();\n\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @private\n * @returns {undefined}\n */\nfunction schedule(emitter) {\n  const timer = safeSetTimeout(() => {\n    const pc = pcsByEmitter.get(emitter);\n    pc.getStats()\n      .then((stats) => {\n        emitter.emit('data', stats);\n        // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n        // enum according to spec, but at time of writing, was still implemented\n        // in the {@link RTCSignalingState} enum.\n        if (!(pc.signalingState === 'closed' || pc.connectionState === 'closed')) {\n          schedule(emitter);\n        }\n      })\n      .catch((err) => {\n        emitter.emit('error', err);\n      });\n  }, 1000);\n\n  timersByEmitter.set(emitter, timer);\n}\n\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its\n * {@link RTCStatsReport}\n */\nexport default class StatsStream extends Readable {\n  /**\n   * @private\n   * @param {RTCPeerConnection} pc\n   */\n  constructor(pc) {\n    super({objectMode: true});\n\n    if (!emittersByPc.has(pc)) {\n      emittersByPc.set(pc, new EventEmitter());\n    }\n    const emitter = emittersByPc.get(pc);\n\n    if (!emittersByStream.has(this)) {\n      emittersByStream.set(this, emitter);\n    }\n    if (!pcsByEmitter.has(emitter)) {\n      pcsByEmitter.set(emitter, pc);\n    }\n\n    emitter.once('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n  _read() {\n    const emitter = emittersByStream.get(this);\n\n    emitter.once('data', (data) => {\n      if (!this.isPaused()) {\n        this.push(data);\n      }\n    });\n\n    if (!timersByEmitter.has(emitter)) {\n      schedule(emitter);\n    }\n  }\n}\n\n"]}