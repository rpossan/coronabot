{"version":3,"sources":["phone.js"],"names":["events","CALL_CREATED","CALL_INCOMING","Phone","SparkPlugin","extend","collections","emittedCalls","Calls","session","connected","default","type","defaultFacingMode","values","registered","namespace","isCallingSupported","resolve","DetectRTC","require","isWebRTCSupported","register","spark","internal","device","refresh","then","all","reset","mercury","when","message","data","bufferState","locus","listActiveCalls","connect","deregister","disconnect","unregister","createLocalMediaStream","options","constraints","audio","video","WebRTCMediaEngine","getUserMedia","list","loci","calls","map","e","forEach","has","callItem","Call","make","parent","push","add","_triggerCallEvents","initialize","args","prototype","listenTo","event","onLocusEvent","url","call","dial","dialString","trigger"],"mappings":"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","file":"phone.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {SparkPlugin} from '@ciscospark/spark-core';\nimport WebRTCMediaEngine from '@ciscospark/media-engine-webrtc';\nimport {defaults, get} from 'lodash';\n\nimport Call from './call';\nimport {isCall, shouldRing} from './state-parsers';\nimport Calls from './calls';\n\nexport const events = {\n  CALL_CREATED: 'call:created',\n  CALL_INCOMING: 'call:incoming'\n};\n\n/**\n * Call Created Event\n *\n * Emitted when a call begins outside of the sdk\n *\n * @event call:created\n * @instance\n * @memberof Phone\n * @type {Object}\n * @property {Call} call The created call\n */\n\n/**\n * Incoming Call Event\n *\n * Emitted when a call begins and when {@link Phone#register} is invoked and\n * there are active calls.\n *\n * @event call:incoming\n * @instance\n * @memberof Phone\n * @type {Object}\n * @property {Call} call The incoming call\n */\n\n/**\n * @class\n */\nconst Phone = SparkPlugin.extend({\n  collections: {\n    emittedCalls: Calls\n  },\n\n  session: {\n    /**\n     * Indicates whether or not the WebSocket is connected\n     * @instance\n     * @memberof Phone\n     * @member {Boolean}\n     * @readonly\n     */\n    connected: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Specifies the facingMode to be used by {@link Phone#dial} and\n     * {@link Call#answer} when no constraint is specified. Does not apply if\n     * - a {@link MediaStream} is passed to {@link Phone#dial} or\n     * {@link Call#answer}\n     * - constraints are passed to {@link Phone#dial} or  {@link Call#answer}\n     * The only valid values are `user` and `environment`. For any other values,\n     * you must provide your own constrains or {@link MediaStream}\n     * @default `user`\n     * @instance\n     * @memberof Phone\n     * @type {string}\n     */\n    defaultFacingMode: {\n      default: 'user',\n      type: 'string',\n      values: ['user', 'environment']\n    },\n    /**\n     * indicates whether or not the client is registered with the Cisco Spark\n     * cloud\n     * @instance\n     * @memberof Phone\n     * @member {Boolean}\n     * @readonly\n     */\n    registered: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  namespace: 'phone',\n\n  /**\n   * Indicates if the current browser appears to support webrtc calling. Note:\n   * at this time, there's no way to determine if the current browser supports\n   * h264 without asking for camera permissions\n   * @instance\n   * @memberof Phone\n   * @returns {Promise<Boolean>}\n   */\n  isCallingSupported() {\n    return new Promise((resolve) => {\n      // I'm not thrilled by this, but detectrtc breaks the global namespace in\n      // a way that screws up the browserOnly/nodeOnly test helpers.\n      // eslint-disable-next-line global-require\n      const DetectRTC = require('detectrtc');\n      resolve(DetectRTC.isWebRTCSupported);\n    });\n  },\n\n  /**\n   * Registers the client with the Cisco Spark cloud and starts listening for\n   * WebSocket events.\n   *\n   * Subsequent calls refresh the device registration.\n   * @instance\n   * @memberof Phone\n   * @returns {Promise}\n   */\n  register() {\n    // Ideally, we could call spark.refresh via spark-core, but it doesn't know\n    // about the wdm plugin, and all of the leaky abstractions I can think of\n    // seem risky.\n\n    return this.spark.internal.device.refresh()\n      .then(() => {\n        if (this.connected) {\n          return Promise.resolve();\n        }\n        return Promise.all([\n          this.emittedCalls.reset(),\n          this.spark.internal.mercury.when('event:mercury.buffer_state')\n            .then(([message]) => {\n              if (message.data.bufferState.locus === 'UNKNOWN') {\n                return this.listActiveCalls();\n              }\n              return Promise.resolve();\n            }),\n          this.spark.internal.mercury.connect()\n        ]);\n      });\n  },\n\n  /**\n   * Disconnects from WebSocket and unregisters from the Cisco Spark cloud.\n   *\n   * Subsequent calls will be a noop.\n   * @instance\n   * @memberof Phone\n   * @returns {Promise}\n   */\n  deregister() {\n    return this.spark.internal.mercury.disconnect()\n      .then(() => this.spark.internal.device.unregister());\n  },\n\n  /**\n   * Create a MediaStream to be used for video preview.\n   *\n   * Note: You must explicitly pass the resultant stream to {@link Call#answer()}\n   * or {@link Phone#dial()}\n   * @instance\n   * @memberof Phone\n   * @param {Object|MediaStreamConstraints} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @returns {Promise<MediaStream>}\n   */\n  createLocalMediaStream(options = {}) {\n    const constraints = options.constraints || options;\n    defaults(constraints, {\n      audio: true,\n      video: true\n    });\n\n    return WebRTCMediaEngine.getUserMedia(constraints);\n  },\n\n  /**\n   * Fetches a list of all of the current user's active calls\n   * @instance\n   * @memberOf Phone\n   * @returns {Promise<Call[]>}\n   */\n  listActiveCalls() {\n    return this.spark.internal.locus.list()\n      .then((loci) => {\n        // emittedCalls is a collection, convert to array\n        const calls = this.emittedCalls.map((e) => e);\n        if (!loci) {\n          return calls;\n        }\n        loci.forEach((locus) => {\n          if (!this.emittedCalls.has(locus)) {\n            const callItem = Call.make({locus, parent: this.spark});\n            calls.push(callItem);\n            this.emittedCalls.add(callItem);\n            this._triggerCallEvents(callItem, locus);\n          }\n        });\n        return calls;\n      });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Phone\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {undefined}\n   */\n  initialize(...args) {\n    Reflect.apply(SparkPlugin.prototype.initialize, this, args);\n\n    this.listenTo(this.spark.internal.mercury, 'event:locus', (event) => this.onLocusEvent(event));\n\n    // Note: we need to manually wire up change:connected because derived props\n    // can't read through this.parent\n    this.listenTo(this.spark.internal.mercury, 'change:connected', () => {\n      this.connected = this.spark.internal.mercury.connected;\n      this.registered = !!this.spark.internal.device.url && this.connected;\n    });\n\n    // Note: we need to manually wire up change:url because derived props\n    // can't read through this.parent\n    this.listenTo(this.spark.internal.device, 'change:url', () => {\n      this.registered = !!this.spark.internal.device.url && this.connected;\n    });\n  },\n\n  /**\n   * Determines if the {@link call:incoming} event should be emitted for the\n   * specified {@link Types~MercuryEvent}\n   * @emits call:incoming\n   * @instance\n   * @memberof Phone\n   * @param {Types~MercuryEvent} event\n   * @private\n   * @returns {undefined}\n   */\n  onLocusEvent(event) {\n    // We only want to handle calls we are not aware of\n    if (this.emittedCalls.has(event.data.locus)) {\n      return;\n    }\n\n    // Create call object and store in emittedCalls\n    const call = Call.make({\n      locus: event.data.locus\n    }, {\n      parent: this.spark\n    });\n    this.emittedCalls.add(call);\n\n    // Trigger events as necessary\n    this._triggerCallEvents(call, event.data.locus);\n  },\n\n  /**\n   * Place a call to the specified dialString. A dial string may be an email\n   * address or sip uri.\n   * If you set {@link config.phone.enableExperimentalGroupCallingSupport} to\n   * `true`, the dialString may also be a room id.\n   * @instance\n   * @memberof Phone\n   * @param {string} dialString\n   * @param {Object} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @param {MediaStream} options.localMediaStream if no stream is specified, a\n   * new one will be created based on options.constraints\n   * @returns {Call}\n   */\n  dial(dialString, options) {\n    const call = Call.make({}, {parent: this.spark});\n\n    call.dial(dialString, options);\n    this.emittedCalls.add(call);\n    return call;\n  },\n\n  /**\n   * Triggers call events for a given call/locus\n   * @param {Call} call\n   * @param {Types~Locus} locus\n   * @returns {undefined}\n   */\n  _triggerCallEvents(call, locus) {\n    this.trigger(events.CALL_CREATED, call);\n\n    if (shouldRing(locus)) {\n      if (isCall(locus) || (!isCall(locus) && get(this, 'config.enableExperimentalGroupCallingSupport'))) {\n        this.trigger(events.CALL_INCOMING, call);\n      }\n    }\n  }\n});\n\nexport default Phone;\n"]}