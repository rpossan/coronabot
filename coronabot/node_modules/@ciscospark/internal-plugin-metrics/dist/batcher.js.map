{"version":3,"sources":["batcher.js"],"names":["sym","MetricsBatcher","Batcher","extend","namespace","prepareItem","item","env","process","NODE_ENV","appType","config","time","Date","now","version","spark","resolve","prepareRequest","queue","map","postTime","submitHttpRequest","payload","request","method","service","resource","body","metrics","handleHttpSuccess","res","all","options","acceptItem","handleHttpError","reason","SparkHttpError","NetworkOrCORSError","logger","warn","delay","nextDelay","batcherRetryPlateau","rerequest","prototype","getDeferredForRequest","then","defer","req","enqueue","bounce","catch","reject","fingerprintRequest","fingerprintResponse"],"mappings":"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","file":"batcher.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Batcher, SparkHttpError} from '@ciscospark/spark-core';\nimport {safeSetTimeout} from '@ciscospark/common-timers';\n\nconst sym = Symbol('metric id');\n\nconst MetricsBatcher = Batcher.extend({\n  namespace: 'Metrics',\n\n  prepareItem(item) {\n    // Keep non-prod data out of metrics\n    const env = process.env.NODE_ENV === 'production' ? null : 'TEST';\n\n    item.appType = item.appType || this.config.appType;\n    item.env = item.env || env;\n    item.time = item.time || Date.now();\n    item.version = item.version || this.spark.version;\n\n    return Promise.resolve(item);\n  },\n\n  prepareRequest(queue) {\n    return Promise.resolve(queue.map((item) => {\n      item.postTime = item.postTime || Date.now();\n      return item;\n    }));\n  },\n\n  submitHttpRequest(payload) {\n    return this.spark.request({\n      method: 'POST',\n      service: 'metrics',\n      resource: 'metrics',\n      body: {\n        metrics: payload\n      }\n    });\n  },\n\n  handleHttpSuccess(res) {\n    return Promise.all(res.options.body.metrics.map((item) => this.acceptItem(item)));\n  },\n\n  handleHttpError(reason) {\n    if (reason instanceof SparkHttpError.NetworkOrCORSError) {\n      this.logger.warn('metrics-batcher: received network error submitting metrics, reenqueuing payload');\n      return Promise.all(reason.options.body.metrics.map((item) => new Promise((resolve) => {\n        const delay = item[sym].nextDelay;\n        if (delay < this.config.batcherRetryPlateau) {\n          item[sym].nextDelay *= 2;\n        }\n        safeSetTimeout(() => {\n          resolve(this.rerequest(item));\n        }, delay);\n      })));\n    }\n\n    return Reflect.apply(Batcher.prototype.handleHttpError, this, [reason]);\n  },\n\n  rerequest(item) {\n    return Promise.all([\n      this.getDeferredForRequest(item),\n      this.prepareItem(item)\n    ])\n      .then(([defer, req]) => {\n        this.enqueue(req)\n          .then(() => this.bounce())\n          .catch((reason) => defer.reject(reason));\n      });\n  },\n\n  fingerprintRequest(item) {\n    item[sym] = item[sym] || {\n      nextDelay: 1000\n    };\n\n    return Promise.resolve(item[sym]);\n  },\n\n  fingerprintResponse(item) {\n    return Promise.resolve(item[sym]);\n  }\n});\n\nexport default MetricsBatcher;\n"]}