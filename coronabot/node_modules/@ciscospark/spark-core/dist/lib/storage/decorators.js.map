{"version":3,"sources":["decorators.js"],"names":["persist","waitForValue","args","length","key","decider","persistDecorator","target","prop","descriptor","TypeError","value","persistExecutor","fn","initializeArgs","ret","changeEvent","on","shouldPersist","resolve","boundedStorage","put","prepareInitialize","M","S","BlockingKeyMap","blockingKeys","Error","waitForValueDecorator","add","waitForValueExecutor","keys","get","all","map","k","waitFor","then","prototype","inited","identifyTarget","namespace","stack","id","has","initialize","applyInit","init","self","getNamespace","spark","set","logger","debug","parent","toLowerCase","handle","reason","NotFoundError","process","env","NODE_ENV","toString","includes","error","reject","promises","forEach","push","catch","delete","size","loaded"],"mappings":"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","file":"decorators.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\nimport {\n  curry,\n  debounce,\n  identity,\n  result,\n  wrap\n} from 'lodash';\nimport {NotFoundError} from './errors';\nimport {make} from '@ciscospark/common';\n\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\nexport function persist(...args) {\n  if (args.length === 3) {\n    return persist('@')(...args);\n  }\n\n  const [key, decider] = args;\n\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = wrap(descriptor.value, function persistExecutor(fn, ...initializeArgs) {\n      const ret = Reflect.apply(fn, this, initializeArgs);\n      const changeEvent = key === '@' ? 'change' : `change:${key}`;\n\n      // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n      this.on(changeEvent, debounce(() => {\n        const shouldPersist = !decider || Reflect.apply(decider, this, ...initializeArgs);\n        if (!shouldPersist) {\n          return Promise.resolve();\n        }\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return this.boundedStorage.put(key, this);\n        }\n\n        // eslint-disable-next-line no-invalid-this\n        return this.boundedStorage.put(key, this[key]);\n      }, 0));\n      return ret;\n    });\n\n    prepareInitialize(target, prop);\n  };\n}\n\nconst M = Map;\nconst S = Set;\nconst BlockingKeyMap = make(M, M, S);\nconst blockingKeys = new BlockingKeyMap();\n\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\nexport function waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = wrap(descriptor.value, function waitForValueExecutor(fn, ...args) {\n      const keys = blockingKeys.get(target, prop);\n      return Promise.all([...keys].map((k) => this.boundedStorage.waitFor(k)))\n        .then(() => Reflect.apply(fn, this, args));\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n\n    return descriptor;\n  };\n}\n\nconst inited = new Set();\n\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nconst stack = new Set();\n\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\nfunction prepareInitialize(target, prop) {\n  const id = identifyTarget(target);\n  if (!inited.has(id)) {\n    inited.add(id);\n    if (target.initialize) {\n      target.initialize = wrap(target.initialize, function applyInit(fn, ...args) {\n        const ret = Reflect.apply(fn, this, args);\n        Reflect.apply(init, this, args);\n        return ret;\n      });\n      return;\n    }\n\n    target.initialize = init;\n  }\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function init() {\n    const self = this;\n    const namespace = this.getNamespace();\n    this.spark.initialize = wrap(this.spark.initialize || identity, function applyInit(fn, ...args) {\n      // Call spark's initalize method first\n      // Reminder: in order for MockSpark to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `spark`, not `self`.\n      stack.add(namespace);\n      Reflect.apply(fn, this, args);\n\n      // Then prepare a function for setting values retrieved from storage\n      const set = curry((key, value) => {\n        this.logger.debug(`storage:(${namespace}): got \\`${key}\\` for first time`);\n        if (key === '@') {\n          self.parent.set({\n            [namespace.toLowerCase()]: value\n          });\n        }\n        else if (result(self[key], 'isState')) {\n          self[key].set(value);\n        }\n        else {\n          self.set(key, value);\n        }\n        this.logger.debug(`storage:(${namespace}): set \\`${key}\\` for first time`);\n      });\n\n      // And prepare an error handler for when those keys can't be found\n      const handle = curry((key, reason) => {\n        if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          this.logger.debug(`storage(${namespace}): no data for \\`${key}\\`, continuing`);\n          return Promise.resolve();\n        }\n        this.logger.error(`storage(${namespace}): failed to init \\`${key}\\``, reason);\n        return Promise.reject(reason);\n      });\n\n      // Iterate over the list of keys marked as blocking via `@waitForValue`\n      const keys = blockingKeys.get(target, prop);\n      const promises = [];\n      keys.forEach((key) => {\n        promises.push(this.boundedStorage.get(namespace, key)\n          .then(set(key))\n          .catch(handle(key)));\n      });\n\n      Promise.all(promises)\n        .then(() => {\n          stack.delete(namespace);\n          if (stack.size === 0) {\n            this.loaded = true;\n          }\n        });\n    });\n  }\n}\n"]}