{"version":3,"sources":["token.js"],"names":["processGrantError","res","statusCode","reject","ErrorConstructor","grantErrors","select","body","error","OAuthError","SparkHttpError","_res","Token","SparkPlugin","extend","keyFactory","scope","derived","canAuthorize","deps","fn","access_token","isExpired","canDownscope","config","client_id","canRefresh","inBrowser","refresh_token","refreshCallback","client_secret","expires","_isExpired","_string","token_type","namespace","props","expires_in","refresh_token_expires","refresh_token_expires_in","default","type","session","previousToken","downscope","logger","info","Error","warn","spark","request","method","uri","tokenUrl","form","grant_type","token","then","parent","initialize","attrs","options","prototype","Date","now","refresh","promise","resolve","redirect_uri","auth","user","pass","sendImmediately","shouldRefreshAccessToken","obj","process","env","NODE_ENV","revoke","unset","catch","revokeUrl","token_type_hint","set","_filterSetParameters","includes","split","toString","validate","service","resource","reason","convApi","CONVERSATION_SERVICE","CONVERSATION_SERVICE_URL","headers","authorization","oneFlight"],"mappings":"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","file":"token.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {pick} from 'lodash';\nimport {inBrowser, oneFlight} from '@ciscospark/common';\nimport {safeSetTimeout} from '@ciscospark/common-timers';\nimport SparkHttpError from '../spark-http-error';\nimport SparkPlugin from '../spark-plugin';\nimport {sortScope} from './scope';\nimport grantErrors, {OAuthError} from './grant-errors';\n\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {SparkHttpError} res\n * @private\n * @returns {GrantError}\n */\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return Promise.reject(res);\n  }\n\n  const ErrorConstructor = grantErrors.select(res.body.error);\n  if (ErrorConstructor === OAuthError && res instanceof SparkHttpError) {\n    return Promise.reject(res);\n  }\n  if (!ErrorConstructor) {\n    return Promise.reject(res);\n  }\n  return Promise.reject(new ErrorConstructor(res._res || res));\n}\n\n/**\n * @class\n */\nconst Token = SparkPlugin.extend({\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn() {\n        if (inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n        return `${this.token_type} ${this.access_token}`;\n      }\n    }\n  },\n\n  namespace: 'Credentials',\n\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  @oneFlight({\n    keyFactory(scope) {\n      return scope;\n    }\n  })\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    this.logger.info(`token: downscoping token to ${scope}`);\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n      return Promise.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      }\n      else {\n        this.logger.warn('token: cannot downscope without client_id');\n      }\n      return Promise.reject(new Error('cannot downscope access token'));\n    }\n\n    // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n    if (scope) {\n      scope = sortScope(scope);\n    }\n\n    // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n    if (scope === sortScope(this.config.scope)) {\n      return Promise.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.spark.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope,\n        client_id: this.config.client_id\n      }\n    })\n      .then((res) => {\n        this.logger.info(`token: downscoped token to ${scope}`);\n        return new Token(Object.assign(res.body, {scope}), {parent: this.parent});\n      });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link SparkPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize(attrs = {}, options = {}) {\n    Reflect.apply(SparkPlugin.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    }\n\n    // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n    if (this.expires) {\n      if (this.expires < Date.now()) {\n        this._isExpired = true;\n      }\n      else {\n        safeSetTimeout(() => {\n          this._isExpired = true;\n        }, this.expires - Date.now());\n      }\n    }\n  },\n\n  @oneFlight\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh() {\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    let promise;\n\n    if (inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = Promise.resolve(this.config.refreshCallback(this.spark, this));\n    }\n\n    return (promise || this.spark.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then((res) => res.body))\n      .then((obj) => {\n        if (!obj) {\n          throw new Error('token: refreshCallback() did not produce an object');\n        }\n        // If the authentication server did not send back a refresh token, copy\n        // the current refresh token and related values to the response (note:\n        // at time of implementation, CI never sends a new refresh token)\n        if (!obj.refresh_token) {\n          Object.assign(obj, pick(this, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n        }\n\n        // If the new token is the same as the previous token, then we may have\n        // found a bug in CI; log the details and reject the Promise\n        if (this.access_token === obj.access_token) {\n          this.logger.error('token: new token matches current token');\n          // log the tokens if it is not production\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error('token: current token:', this.access_token);\n            this.logger.error('token: new token:', obj.access_token);\n          }\n          return Promise.reject(new Error('new token matches current token'));\n        }\n\n        if (this.previousToken) {\n          this.previousToken.revoke();\n          this.unset('previousToken');\n        }\n\n        obj.previousToken = this;\n        obj.scope = this.scope;\n\n        return new Token(obj, {parent: this.parent});\n      })\n      .catch(processGrantError);\n  },\n\n  @oneFlight\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke() {\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n      return Promise.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n      return Promise.resolve();\n    }\n\n    // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n      return Promise.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n    return this.spark.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then(() => {\n        this.unset([\n          'access_token',\n          'expires',\n          'expires_in',\n          'token_type'\n        ]);\n        this.logger.info('token: access token revoked');\n      })\n      .catch(processGrantError);\n  },\n\n  set(...args) {\n    // eslint-disable-next-line prefer-const\n    let [attrs, options] = this._filterSetParameters(...args);\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      const [token_type, access_token] = attrs.access_token.split(' ');\n      attrs = Object.assign({}, attrs, {access_token, token_type});\n    }\n    const now = Date.now();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = sortScope(attrs.scope);\n    }\n\n    return Reflect.apply(SparkPlugin.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate() {\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.spark.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    })\n      .catch((reason) => {\n        if ('statusCode' in reason) {\n          return Promise.reject(reason);\n        }\n        this.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal');\n\n        // If we got an error that isn't a SparkHttpError, assume the problem is\n        // that we don't have the wdm plugin loaded and service/resource isn't\n        // a valid means of identifying a request.\n        const convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n        return this.spark.request({\n          method: 'POST',\n          uri: `${convApi}/users/validateAuthToken`,\n          body: {\n            token: this.access_token\n          },\n          headers: {\n            authorization: `Bearer ${this.access_token}`\n          }\n        });\n      })\n      .then((res) => res.body);\n  }\n});\n\nexport default Token;\n"]}